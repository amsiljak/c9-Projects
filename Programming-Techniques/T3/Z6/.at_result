{
    "buildhost_description": {
        "id": "lab002c01",
        "os": "Linux 2.6.32-754.2.1.el6.x86_64 x86_64\n\"CentOS release 6.10 (Final)\"\n",
        "compiler_version": "g++ (GCC) 6.2.0",
        "debugger_version": "GNU gdb (GDB) 7.12",
        "profiler_version": "valgrind-3.12.0"
    },
    "status": 4,
    "compile_result": {
        "status": 1,
        "output": ""
    },
    "run_result": [],
    "debug_result": [],
    "profile_result": [],
    "test_results": {
        "3236": {
            "status": 5,
            "run_result": {
                "output": "Unesite broj elemenata prvog vektora: Unesite elemente prvog vektora: Unesite broj elemenata drugog vektora: ",
                "duration": 0,
                "status": 3,
                "core": "/tmp/buildservice/bs_4452/core.11517"
            },
            "debug_result": {
                "output": "[New LWP 11517]\nCore was generated by `bs_test_3236'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3236.cpp:60\n60\t            m[i][j]=v1[i]*v2[j];\nTo enable execution of this file add\n\tadd-auto-load-safe-path /opt/gcc-6.2.0/lib64/libstdc++.so.6.0.22-gdb.py\nline to your configuration file \"$HOME/.gdbinit\".\nTo completely disable this security protection add\n\tset auto-load safe-path /\nline to your configuration file \"$HOME/.gdbinit\".\nFor more information about this security protection see the\n\"Auto-loading safe path\" section in the GDB manual.  E.g., run from the shell:\n\tinfo \"(gdb)Auto-loading safe path\"\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3236.cpp:60\n#1  0x0000000000401480 in _main () at bs_test_3236.cpp:84\n#2  0x00000000004016e7 in main () at bs_test_3236.cpp:103",
                "parsed_output": [
                    {
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "profile_result": {
                "output": "==11529== Memcheck, a memory error detector\n==11529== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==11529== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\n==11529== Command: bs_test_3236\n==11529== Parent PID: 11528\n==11529== \n==11529== Invalid write of size 4\n==11529==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3236.cpp:60)\n==11529==    by 0x40147F: _main() (bs_test_3236.cpp:84)\n==11529==    by 0x4016E6: main (bs_test_3236.cpp:103)\n==11529==  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n==11529== \n==11529== \n==11529== Process terminating with default action of signal 11 (SIGSEGV)\n==11529==  Access not within mapped region at address 0x0\n==11529==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3236.cpp:60)\n==11529==    by 0x40147F: _main() (bs_test_3236.cpp:84)\n==11529==    by 0x4016E6: main (bs_test_3236.cpp:103)\n==11529==  If you believe this happened as a result of a stack\n==11529==  overflow in your program's main thread (unlikely but\n==11529==  possible), you can try to increase the size of the\n==11529==  main thread stack using the --main-stacksize= flag.\n==11529==  The main thread stack size used in this run was 10485760.\n==11529== \n==11529== HEAP SUMMARY:\n==11529==     in use at exit: 272 bytes in 5 blocks\n==11529==   total heap usage: 7 allocs, 2 frees, 73,072 bytes allocated\n==11529== \n==11529== LEAK SUMMARY:\n==11529==    definitely lost: 0 bytes in 0 blocks\n==11529==    indirectly lost: 0 bytes in 0 blocks\n==11529==      possibly lost: 0 bytes in 0 blocks\n==11529==    still reachable: 272 bytes in 5 blocks\n==11529==         suppressed: 0 bytes in 0 blocks\n==11529== Reachable blocks (those to which a pointer was found) are not shown.\n==11529== To see them, rerun with: --leak-check=full --show-leak-kinds=all\n==11529== \n==11529== For counts of detected and suppressed errors, rerun with: -v\n==11529== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)\n",
                "status": 2,
                "parsed_output": [
                    {
                        "type": 2,
                        "output": " Invalid write of size 4\n    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3236.cpp:60)\n    by 0x40147F: _main() (bs_test_3236.cpp:84)\n    by 0x4016E6: main (bs_test_3236.cpp:103)\n  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n",
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3237": {
            "status": 5,
            "run_result": {
                "output": "Unesite broj elemenata prvog vektora: Unesite elemente prvog vektora: Unesite broj elemenata drugog vektora: ",
                "duration": 0,
                "status": 3,
                "core": "/tmp/buildservice/bs_4452/core.11547"
            },
            "debug_result": {
                "output": "[New LWP 11547]\nCore was generated by `bs_test_3237'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3237.cpp:60\n60\t            m[i][j]=v1[i]*v2[j];\nTo enable execution of this file add\n\tadd-auto-load-safe-path /opt/gcc-6.2.0/lib64/libstdc++.so.6.0.22-gdb.py\nline to your configuration file \"$HOME/.gdbinit\".\nTo completely disable this security protection add\n\tset auto-load safe-path /\nline to your configuration file \"$HOME/.gdbinit\".\nFor more information about this security protection see the\n\"Auto-loading safe path\" section in the GDB manual.  E.g., run from the shell:\n\tinfo \"(gdb)Auto-loading safe path\"\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3237.cpp:60\n#1  0x0000000000401480 in _main () at bs_test_3237.cpp:84\n#2  0x00000000004016e7 in main () at bs_test_3237.cpp:103",
                "parsed_output": [
                    {
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "profile_result": {
                "output": "==11559== Memcheck, a memory error detector\n==11559== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==11559== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\n==11559== Command: bs_test_3237\n==11559== Parent PID: 11558\n==11559== \n==11559== Invalid write of size 4\n==11559==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3237.cpp:60)\n==11559==    by 0x40147F: _main() (bs_test_3237.cpp:84)\n==11559==    by 0x4016E6: main (bs_test_3237.cpp:103)\n==11559==  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n==11559== \n==11559== \n==11559== Process terminating with default action of signal 11 (SIGSEGV)\n==11559==  Access not within mapped region at address 0x0\n==11559==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3237.cpp:60)\n==11559==    by 0x40147F: _main() (bs_test_3237.cpp:84)\n==11559==    by 0x4016E6: main (bs_test_3237.cpp:103)\n==11559==  If you believe this happened as a result of a stack\n==11559==  overflow in your program's main thread (unlikely but\n==11559==  possible), you can try to increase the size of the\n==11559==  main thread stack using the --main-stacksize= flag.\n==11559==  The main thread stack size used in this run was 10485760.\n==11559== \n==11559== HEAP SUMMARY:\n==11559==     in use at exit: 336 bytes in 5 blocks\n==11559==   total heap usage: 7 allocs, 2 frees, 73,160 bytes allocated\n==11559== \n==11559== LEAK SUMMARY:\n==11559==    definitely lost: 0 bytes in 0 blocks\n==11559==    indirectly lost: 0 bytes in 0 blocks\n==11559==      possibly lost: 0 bytes in 0 blocks\n==11559==    still reachable: 336 bytes in 5 blocks\n==11559==         suppressed: 0 bytes in 0 blocks\n==11559== Reachable blocks (those to which a pointer was found) are not shown.\n==11559== To see them, rerun with: --leak-check=full --show-leak-kinds=all\n==11559== \n==11559== For counts of detected and suppressed errors, rerun with: -v\n==11559== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)\n",
                "status": 2,
                "parsed_output": [
                    {
                        "type": 2,
                        "output": " Invalid write of size 4\n    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3237.cpp:60)\n    by 0x40147F: _main() (bs_test_3237.cpp:84)\n    by 0x4016E6: main (bs_test_3237.cpp:103)\n  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n",
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3238": {
            "status": 1,
            "run_result": {
                "output": "_",
                "duration": 0,
                "status": 1
            },
            "debug_result": [],
            "profile_result": [],
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3239": {
            "status": 1,
            "run_result": {
                "output": "_",
                "duration": 0,
                "status": 1
            },
            "debug_result": [],
            "profile_result": [],
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3240": {
            "status": 5,
            "run_result": {
                "output": "",
                "duration": 0,
                "status": 3,
                "core": "/tmp/buildservice/bs_4452/core.11613"
            },
            "debug_result": {
                "output": "[New LWP 11613]\nCore was generated by `bs_test_3240'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3240.cpp:60\n60\t            m[i][j]=v1[i]*v2[j];\nTo enable execution of this file add\n\tadd-auto-load-safe-path /opt/gcc-6.2.0/lib64/libstdc++.so.6.0.22-gdb.py\nline to your configuration file \"$HOME/.gdbinit\".\nTo completely disable this security protection add\n\tset auto-load safe-path /\nline to your configuration file \"$HOME/.gdbinit\".\nFor more information about this security protection see the\n\"Auto-loading safe path\" section in the GDB manual.  E.g., run from the shell:\n\tinfo \"(gdb)Auto-loading safe path\"\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3240.cpp:60\n#1  0x000000000040179b in main () at bs_test_3240.cpp:106",
                "parsed_output": [
                    {
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "profile_result": {
                "output": "==11625== Memcheck, a memory error detector\n==11625== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==11625== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\n==11625== Command: bs_test_3240\n==11625== Parent PID: 11624\n==11625== \n==11625== Invalid write of size 4\n==11625==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3240.cpp:60)\n==11625==    by 0x40179A: main (bs_test_3240.cpp:106)\n==11625==  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n==11625== \n==11625== \n==11625== Process terminating with default action of signal 11 (SIGSEGV)\n==11625==  Access not within mapped region at address 0x0\n==11625==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3240.cpp:60)\n==11625==    by 0x40179A: main (bs_test_3240.cpp:106)\n==11625==  If you believe this happened as a result of a stack\n==11625==  overflow in your program's main thread (unlikely but\n==11625==  possible), you can try to increase the size of the\n==11625==  main thread stack using the --main-stacksize= flag.\n==11625==  The main thread stack size used in this run was 10485760.\n==11625== \n==11625== HEAP SUMMARY:\n==11625==     in use at exit: 40 bytes in 5 blocks\n==11625==   total heap usage: 6 allocs, 1 frees, 72,744 bytes allocated\n==11625== \n==11625== LEAK SUMMARY:\n==11625==    definitely lost: 0 bytes in 0 blocks\n==11625==    indirectly lost: 0 bytes in 0 blocks\n==11625==      possibly lost: 0 bytes in 0 blocks\n==11625==    still reachable: 40 bytes in 5 blocks\n==11625==         suppressed: 0 bytes in 0 blocks\n==11625== Reachable blocks (those to which a pointer was found) are not shown.\n==11625== To see them, rerun with: --leak-check=full --show-leak-kinds=all\n==11625== \n==11625== For counts of detected and suppressed errors, rerun with: -v\n==11625== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)\n",
                "status": 2,
                "parsed_output": [
                    {
                        "type": 2,
                        "output": " Invalid write of size 4\n    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3240.cpp:60)\n    by 0x40179A: main (bs_test_3240.cpp:106)\n  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n",
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3241": {
            "status": 5,
            "run_result": {
                "output": "",
                "duration": 0,
                "status": 3,
                "core": "/tmp/buildservice/bs_4452/core.11643"
            },
            "debug_result": {
                "output": "[New LWP 11643]\nCore was generated by `bs_test_3241'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3241.cpp:60\n60\t            m[i][j]=v1[i]*v2[j];\nTo enable execution of this file add\n\tadd-auto-load-safe-path /opt/gcc-6.2.0/lib64/libstdc++.so.6.0.22-gdb.py\nline to your configuration file \"$HOME/.gdbinit\".\nTo completely disable this security protection add\n\tset auto-load safe-path /\nline to your configuration file \"$HOME/.gdbinit\".\nFor more information about this security protection see the\n\"Auto-loading safe path\" section in the GDB manual.  E.g., run from the shell:\n\tinfo \"(gdb)Auto-loading safe path\"\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3241.cpp:60\n#1  0x00000000004017cb in main () at bs_test_3241.cpp:106",
                "parsed_output": [
                    {
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "profile_result": {
                "output": "==11655== Memcheck, a memory error detector\n==11655== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==11655== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\n==11655== Command: bs_test_3241\n==11655== Parent PID: 11654\n==11655== \n==11655== Invalid write of size 4\n==11655==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3241.cpp:60)\n==11655==    by 0x4017CA: main (bs_test_3241.cpp:106)\n==11655==  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n==11655== \n==11655== \n==11655== Process terminating with default action of signal 11 (SIGSEGV)\n==11655==  Access not within mapped region at address 0x0\n==11655==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3241.cpp:60)\n==11655==    by 0x4017CA: main (bs_test_3241.cpp:106)\n==11655==  If you believe this happened as a result of a stack\n==11655==  overflow in your program's main thread (unlikely but\n==11655==  possible), you can try to increase the size of the\n==11655==  main thread stack using the --main-stacksize= flag.\n==11655==  The main thread stack size used in this run was 10485760.\n==11655== \n==11655== HEAP SUMMARY:\n==11655==     in use at exit: 80 bytes in 5 blocks\n==11655==   total heap usage: 6 allocs, 1 frees, 72,784 bytes allocated\n==11655== \n==11655== LEAK SUMMARY:\n==11655==    definitely lost: 0 bytes in 0 blocks\n==11655==    indirectly lost: 0 bytes in 0 blocks\n==11655==      possibly lost: 0 bytes in 0 blocks\n==11655==    still reachable: 80 bytes in 5 blocks\n==11655==         suppressed: 0 bytes in 0 blocks\n==11655== Reachable blocks (those to which a pointer was found) are not shown.\n==11655== To see them, rerun with: --leak-check=full --show-leak-kinds=all\n==11655== \n==11655== For counts of detected and suppressed errors, rerun with: -v\n==11655== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)\n",
                "status": 2,
                "parsed_output": [
                    {
                        "type": 2,
                        "output": " Invalid write of size 4\n    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3241.cpp:60)\n    by 0x4017CA: main (bs_test_3241.cpp:106)\n  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n",
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3242": {
            "status": 5,
            "run_result": {
                "output": "",
                "duration": 0,
                "status": 3,
                "core": "/tmp/buildservice/bs_4452/core.11673"
            },
            "debug_result": {
                "output": "[New LWP 11673]\nCore was generated by `bs_test_3242'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3242.cpp:60\n60\t            m[i][j]=v1[i]*v2[j];\nTo enable execution of this file add\n\tadd-auto-load-safe-path /opt/gcc-6.2.0/lib64/libstdc++.so.6.0.22-gdb.py\nline to your configuration file \"$HOME/.gdbinit\".\nTo completely disable this security protection add\n\tset auto-load safe-path /\nline to your configuration file \"$HOME/.gdbinit\".\nFor more information about this security protection see the\n\"Auto-loading safe path\" section in the GDB manual.  E.g., run from the shell:\n\tinfo \"(gdb)Auto-loading safe path\"\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3242.cpp:60\n#1  0x00000000004017cb in main () at bs_test_3242.cpp:106",
                "parsed_output": [
                    {
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "profile_result": {
                "output": "==11685== Memcheck, a memory error detector\n==11685== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==11685== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\n==11685== Command: bs_test_3242\n==11685== Parent PID: 11684\n==11685== \n==11685== Invalid write of size 4\n==11685==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3242.cpp:60)\n==11685==    by 0x4017CA: main (bs_test_3242.cpp:106)\n==11685==  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n==11685== \n==11685== \n==11685== Process terminating with default action of signal 11 (SIGSEGV)\n==11685==  Access not within mapped region at address 0x0\n==11685==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3242.cpp:60)\n==11685==    by 0x4017CA: main (bs_test_3242.cpp:106)\n==11685==  If you believe this happened as a result of a stack\n==11685==  overflow in your program's main thread (unlikely but\n==11685==  possible), you can try to increase the size of the\n==11685==  main thread stack using the --main-stacksize= flag.\n==11685==  The main thread stack size used in this run was 10485760.\n==11685== \n==11685== HEAP SUMMARY:\n==11685==     in use at exit: 80 bytes in 5 blocks\n==11685==   total heap usage: 6 allocs, 1 frees, 72,784 bytes allocated\n==11685== \n==11685== LEAK SUMMARY:\n==11685==    definitely lost: 0 bytes in 0 blocks\n==11685==    indirectly lost: 0 bytes in 0 blocks\n==11685==      possibly lost: 0 bytes in 0 blocks\n==11685==    still reachable: 80 bytes in 5 blocks\n==11685==         suppressed: 0 bytes in 0 blocks\n==11685== Reachable blocks (those to which a pointer was found) are not shown.\n==11685== To see them, rerun with: --leak-check=full --show-leak-kinds=all\n==11685== \n==11685== For counts of detected and suppressed errors, rerun with: -v\n==11685== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)\n",
                "status": 2,
                "parsed_output": [
                    {
                        "type": 2,
                        "output": " Invalid write of size 4\n    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3242.cpp:60)\n    by 0x4017CA: main (bs_test_3242.cpp:106)\n  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n",
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3243": {
            "status": 5,
            "run_result": {
                "output": "",
                "duration": 0,
                "status": 3,
                "core": "/tmp/buildservice/bs_4452/core.11704"
            },
            "debug_result": {
                "output": "[New LWP 11704]\nCore was generated by `bs_test_3243'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x0000000000401bc6 in std::vector<int, std::allocator<int> >::operator[] (this=0x0, __n=0) at /opt/gcc-6.2.0/include/c++/6.2.0/bits/stl_vector.h:781\n781\t      { return *(this->_M_impl._M_start + __n); }\nTo enable execution of this file add\n\tadd-auto-load-safe-path /opt/gcc-6.2.0/lib64/libstdc++.so.6.0.22-gdb.py\nline to your configuration file \"$HOME/.gdbinit\".\nTo completely disable this security protection add\n\tset auto-load safe-path /\nline to your configuration file \"$HOME/.gdbinit\".\nFor more information about this security protection see the\n\"Auto-loading safe path\" section in the GDB manual.  E.g., run from the shell:\n\tinfo \"(gdb)Auto-loading safe path\"\n#0  0x0000000000401bc6 in std::vector<int, std::allocator<int> >::operator[] (this=0x0, __n=0) at /opt/gcc-6.2.0/include/c++/6.2.0/bits/stl_vector.h:781\n#1  0x000000000040105b in NajvecaSirina (m=...) at bs_test_3243.cpp:38\n#2  0x0000000000401752 in main () at bs_test_3243.cpp:106",
                "parsed_output": [
                    {
                        "file": "main.cpp",
                        "line": 32
                    }
                ]
            },
            "profile_result": {
                "output": "==11724== Memcheck, a memory error detector\n==11724== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==11724== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\n==11724== Command: bs_test_3243\n==11724== Parent PID: 11723\n==11724== \n==11724== Invalid read of size 8\n==11724==    at 0x401BC6: std::vector<int, std::allocator<int> >::operator[](unsigned long) (stl_vector.h:781)\n==11724==    by 0x40105A: NajvecaSirina(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >) (bs_test_3243.cpp:38)\n==11724==    by 0x401751: main (bs_test_3243.cpp:106)\n==11724==  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n==11724== \n==11724== \n==11724== Process terminating with default action of signal 11 (SIGSEGV)\n==11724==  Access not within mapped region at address 0x0\n==11724==    at 0x401BC6: std::vector<int, std::allocator<int> >::operator[](unsigned long) (stl_vector.h:781)\n==11724==    by 0x40105A: NajvecaSirina(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >) (bs_test_3243.cpp:38)\n==11724==    by 0x401751: main (bs_test_3243.cpp:106)\n==11724==  If you believe this happened as a result of a stack\n==11724==  overflow in your program's main thread (unlikely but\n==11724==  possible), you can try to increase the size of the\n==11724==  main thread stack using the --main-stacksize= flag.\n==11724==  The main thread stack size used in this run was 10485760.\n==11724== \n==11724== HEAP SUMMARY:\n==11724==     in use at exit: 0 bytes in 0 blocks\n==11724==   total heap usage: 1 allocs, 1 frees, 72,704 bytes allocated\n==11724== \n==11724== All heap blocks were freed -- no leaks are possible\n==11724== \n==11724== For counts of detected and suppressed errors, rerun with: -v\n==11724== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)\n",
                "status": 2,
                "parsed_output": [
                    {
                        "type": 2,
                        "output": " Invalid read of size 8\n    at 0x401BC6: std::vector<int, std::allocator<int> >::operator[](unsigned long) (stl_vector.h:781)\n    by 0x40105A: NajvecaSirina(std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >) (bs_test_3243.cpp:38)\n    by 0x401751: main (bs_test_3243.cpp:106)\n  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n",
                        "file": "main.cpp",
                        "line": 32
                    }
                ]
            },
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3244": {
            "status": 1,
            "run_result": {
                "output": "Sirina: 8",
                "duration": 0,
                "status": 1
            },
            "debug_result": [],
            "profile_result": [],
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3245": {
            "status": 1,
            "run_result": {
                "output": "Sirina: 5\nSirina: 6",
                "duration": 0,
                "status": 1
            },
            "debug_result": [],
            "profile_result": [],
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3246": {
            "status": 6,
            "run_result": {
                "output": "Sirina: 2\n",
                "duration": 0,
                "status": 1
            },
            "debug_result": [],
            "profile_result": [],
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3247": {
            "status": 1,
            "run_result": {
                "output": "Sirina: 10\n",
                "duration": 0,
                "status": 1
            },
            "debug_result": [],
            "profile_result": [],
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3248": {
            "status": 1,
            "run_result": {
                "output": "5",
                "duration": 0,
                "status": 1
            },
            "debug_result": [],
            "profile_result": [],
            "compile_result": {
                "status": 1,
                "output": ""
            }
        },
        "3249": {
            "status": 5,
            "run_result": {
                "output": "Unesite broj elemenata prvog vektora: Unesite elemente prvog vektora: Unesite broj elemenata drugog vektora: ",
                "duration": 0,
                "status": 3,
                "core": "/tmp/buildservice/bs_4452/core.11834"
            },
            "debug_result": {
                "output": "[New LWP 11834]\nCore was generated by `bs_test_3249'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3249.cpp:60\n60\t            m[i][j]=v1[i]*v2[j];\nTo enable execution of this file add\n\tadd-auto-load-safe-path /opt/gcc-6.2.0/lib64/libstdc++.so.6.0.22-gdb.py\nline to your configuration file \"$HOME/.gdbinit\".\nTo completely disable this security protection add\n\tset auto-load safe-path /\nline to your configuration file \"$HOME/.gdbinit\".\nFor more information about this security protection see the\n\"Auto-loading safe path\" section in the GDB manual.  E.g., run from the shell:\n\tinfo \"(gdb)Auto-loading safe path\"\n#0  0x000000000040127e in KroneckerovProizvod (v1=..., v2=...) at bs_test_3249.cpp:60\n#1  0x0000000000401480 in _main () at bs_test_3249.cpp:84\n#2  0x00000000004016e7 in main () at bs_test_3249.cpp:103",
                "parsed_output": [
                    {
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "profile_result": {
                "output": "==11846== Memcheck, a memory error detector\n==11846== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==11846== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info\n==11846== Command: bs_test_3249\n==11846== Parent PID: 11845\n==11846== \n==11846== Invalid write of size 4\n==11846==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3249.cpp:60)\n==11846==    by 0x40147F: _main() (bs_test_3249.cpp:84)\n==11846==    by 0x4016E6: main (bs_test_3249.cpp:103)\n==11846==  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n==11846== \n==11846== \n==11846== Process terminating with default action of signal 11 (SIGSEGV)\n==11846==  Access not within mapped region at address 0x0\n==11846==    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3249.cpp:60)\n==11846==    by 0x40147F: _main() (bs_test_3249.cpp:84)\n==11846==    by 0x4016E6: main (bs_test_3249.cpp:103)\n==11846==  If you believe this happened as a result of a stack\n==11846==  overflow in your program's main thread (unlikely but\n==11846==  possible), you can try to increase the size of the\n==11846==  main thread stack using the --main-stacksize= flag.\n==11846==  The main thread stack size used in this run was 10485760.\n==11846== \n==11846== HEAP SUMMARY:\n==11846==     in use at exit: 80 bytes in 5 blocks\n==11846==   total heap usage: 6 allocs, 1 frees, 72,784 bytes allocated\n==11846== \n==11846== LEAK SUMMARY:\n==11846==    definitely lost: 0 bytes in 0 blocks\n==11846==    indirectly lost: 0 bytes in 0 blocks\n==11846==      possibly lost: 0 bytes in 0 blocks\n==11846==    still reachable: 80 bytes in 5 blocks\n==11846==         suppressed: 0 bytes in 0 blocks\n==11846== Reachable blocks (those to which a pointer was found) are not shown.\n==11846== To see them, rerun with: --leak-check=full --show-leak-kinds=all\n==11846== \n==11846== For counts of detected and suppressed errors, rerun with: -v\n==11846== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)\n",
                "status": 2,
                "parsed_output": [
                    {
                        "type": 2,
                        "output": " Invalid write of size 4\n    at 0x40127E: KroneckerovProizvod(std::vector<int, std::allocator<int> >, std::vector<int, std::allocator<int> >) (bs_test_3249.cpp:60)\n    by 0x40147F: _main() (bs_test_3249.cpp:84)\n    by 0x4016E6: main (bs_test_3249.cpp:103)\n  Address 0x0 is not stack'd, malloc'd or (recently) free'd\n",
                        "file": "main.cpp",
                        "line": 54
                    }
                ]
            },
            "compile_result": {
                "status": 1,
                "output": ""
            }
        }
    },
    "queue_items": 1,
    "time": 1553624564
}